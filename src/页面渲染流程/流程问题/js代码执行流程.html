<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="exporter-version" content="Evernote Mac 9.4.1 (460858)" />
		<meta name="created" content="2020-08-09 07:24:47 +0000" />
		<meta name="source" content="desktop.mac" />
		<meta name="updated" content="2020-08-09 09:40:23 +0000" />
		<title>
			js代码执行流程
		</title>
	</head>
	<body>
		<ol>
			<li>
				<div>
					实际上变量和函数声明在代码里的位置是不会改变的，而是在编译阶段被Javascript引擎放入内存中。一段js代码在执行之前需要被js引擎编译，编译完成之后才会进入执行阶段，大致流程如下：
				</div>
			</li>
		</ol>
		<div style="text-align: center; ">
			               
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/649c6e3b5509ffd40e13ce9c91b3d91e.png"
			height="203" width="1142" />
			<br/>
		</div>
		<ol start="2">
			<li>
				<div style="text-align: left;">
					<span style="font-weight: bold;">
						编译阶段：
					</span>
					以代码为例
				</div>
			</li>
		</ol>
		<div style="text-align: left;">
			<span style="font-size: unset; color: unset; font-family: unset;">
				           showName()；
			</span>
		</div>
		<div style="text-align: left;">
			<span style="font-size: unset; color: unset; font-family: unset;">
				           console.log(myname)；
			</span>
		</div>
		<div style="text-align: left;">
			<span style="font-size: unset; color: unset; font-family: unset;">
				           var myname = '极客时间'；
			</span>
		</div>
		<div style="text-align: left;">
			<span style="font-size: unset; color: unset; font-family: unset;">
				           function showName() {
			</span>
		</div>
		<div style="text-align: left;">
			<span style="font-size: unset; color: unset; font-family: unset;">
				               console.log('函数showName被执行');
			</span>
		</div>
		<div style="text-align: left;">
			<span style="font-size: unset; color: unset; font-family: unset;">
				           }
			</span>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					第一部分：变量提升部分代码——function showName（）{console.log(‘lisi’)} var name = undefined;
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					第二部分： 执行部分代码——showName(); console.log(name); name = ‘zhangsan’;
				</div>
			</li>
		</ul>
		<div style="text-align: center;">
			      
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/0655d18ec347a95dfbf843969a921a13.png"
			height="634" width="1142" />
			<br/>
		</div>
		<div>
			从上图可以看出一段js代码经过编译后，会生成两部分内容：执行上下文（execution context）和可执行代码
		</div>
		<div>
			分析以上代码的执行步骤：
		</div>
		<div>
			<br/>
		</div>
		<ul>
			<li>
				<div>
					第一行和第二行，由于这两行代码不是声明操作，所以在编译阶段，js引擎不会做任何处理
				</div>
			</li>
			<li>
				<div>
					第三行是经过var申明的，因此js引擎会在变量环境对象中创建一个名为myname的属性，并使用undefined对其初始化。
				</div>
			</li>
			<li>
				<div>
					第四行js引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆（HEAP）中，并在环境变量对象中创建一个showname的属性，然后将该属性指向堆中函数的位置。
				</div>
			</li>
			<li>
				<div>
					通过以上步骤就生成了变量环境对象（ViriableEnvironment），接下来js引擎会把声明以外的代码编译为字节码。
				</div>
			</li>
		</ul>
		<div>
			<br/>
		</div>
		<ol start="3">
			<li>
				<div>
					<span style="font-weight: bold;">
						调用栈
					</span>
					： js中经常会出现在一个函数中调用另一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。
				</div>
			</li>
		</ol>
		<ul>
			<li>
				<div>
					 以代码为例：
				</div>
			</li>
		</ul>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				      var a = 2；
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				      function add(){
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				         var b = 10；
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				        return  a+b；
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				     }
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				    add()；
			</span>
		</div>
		<ul>
			<li>
				<div>
					在执行到add函数之前，js引擎会为上面这段代码创建全局执行上下文环境，包含了声明的函数和变量
				</div>
			</li>
		</ul>
		<div style="text-align: center; ">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/7fa2ed18e702861890d767ea547533da.png"
			height="644" width="1142" />
			<br/>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					执行上下文准备好之后便开始执行全局代码，当执行到add()，js判断这是一个函数的调用，首先从全局执行上下文函数中取出add函数代码
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					其次对add函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					最后执行代码输出结果
				</div>
			</li>
		</ul>
		<div style="text-align: center;">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/537efd9e96771dc50737117e615533ca.png"
			height="558" width="1142" />
			<br/>
		</div>
		<ol start="4">
			<li>
				<div>
					<span style="font-weight: bold;">
						什么是JavaScript的调用栈：
					</span>
					在执行上下文创建好后，js引擎会讲执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称为调用栈
				</div>
			</li>
			<li>
				<div>
					<span style="font-weight: bold;">
						作用域：
					</span>
					是指在程序中定义变量的区域，该位置决定了变量的声明周期。通俗的地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
				</div>
			</li>
		</ol>
		<div>
			<span style="font-weight: bold;">
				备注：
			</span>
			在词法环境（lexicalEnvironment）中维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块之后，就会把该作用域内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出。块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境实现的。
		</div>
		<div>
			<br/>
		</div>
		<ol start="6">
			<li>
				<div>
					<span style="font-size: unset; color: unset; font-family: unset;">
						function bar() {
					</span>
					<span style="font-size: unset; color: unset; font-family: unset;">
						   
					</span>
				</div>
			</li>
		</ol>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				              console.log(myName);
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				          }
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				         function foo() {
			</span>
			<span style="font-size: unset; color: unset; font-family: unset;">
				 
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				             var myName = "极客邦"
			</span>
			<span style="font-size: unset; color: unset; font-family: unset;">
				  ;
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				             bar();
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				      }
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				     var myName = "极客时间";
			</span>
		</div>
		<div>
			<span style="font-size: unset; color: unset; font-family: unset;">
				     foo();
			</span>
		</div>
		<div>
			以上代码的调用栈如下：
		</div>
		<div style="text-align: center; ">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/87d8bbc2bb62b03131802fba074146f7.png"
			height="675" width="1142" />
			<br/>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					在每个执行上下文的环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					当一段代码使用了一个变量时，js引擎首先会在“当前执行上下文”中查找该变量
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					比如以上代码，在查找myname变量时，如果在当前变量环境中没有找到，那么js引擎会继续在outer所指引的执行上下文中查找。如下图
				</div>
			</li>
		</ul>
		<div style="text-align: center;">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/20a832656434264db47c93e657e346a7.png"
			height="797" width="1142" />
			<br/>
		</div>
		<ul>
			<li>
				<div>
					从上图中可以看出bar函数和foo函数的outer都指向全局上下文的，这也就意味着如果在bar函数或foo函数中使用了外部变量，那么js引擎会去全局上下文中查找，我们把这个查找的链条称为
					<span style="font-weight: bold;">
						作用域链
					</span>
				</div>
			</li>
		</ul>
		<ol start="7">
			<li>
				<div>
					<span style="font-weight: bold;">
						词法作用域： 是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能预测代码在执行过程中如何查找标识符。
					</span>
					如下图所示
				</div>
			</li>
		</ol>
		<div style="text-align: center; ">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/216433d2d0c64149a731d84ba1a07739.png"
			height="864" width="1142" />
			<br/>
		</div>
		<div style="text-align: left;">
			从图中可以看出，词法作用域就是根据代码位置来决定的，其中main函数包含了bar函数，bar函数中包含了foo函数，因为js作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo函数作用域==&gt;bar函数作用域==&gt;main函数作用域。
		</div>
		<div style="text-align: left;">
			<span style="font-weight: bold;">
				词法作用域是代码编译阶段就决定好的，和函数怎么调用没有关系。
			</span>
		</div>
		<div style="text-align: left;">
			<br/>
		</div>
		<ol start="8">
			<li>
				<div style="text-align: left;">
					<span style="font-weight: bold;">
						闭包： 
					</span>
				</div>
			</li>
		</ol>
		<ul>
			<li>
				<div style="text-align: left;">
					<span style="color: unset; font-family: unset;">
						function foo() {
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    var myName = "极客时间"
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    let test1 = 1
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    const test2 = 2
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    var innerBar = {
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					        getName:function(){
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					            console.log(test1)
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					            return myName
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					        },
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					        setName:function(newName){
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					            myName = newName
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					        }
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    }
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    return innerBar
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					}
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					var bar = foo()
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					bar.setName("极客邦")
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					bar.getName()
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					console.log(bar.getName())
				</div>
			</li>
		</ul>
		<div style="text-align: left;">
			首先当代码执行到foo函数内部的return innerBar时调用栈的情况如下图： 
		</div>
		<div style="text-align: center;">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/d5587b76427a56c5f0b0571e4264b7ef.png"
			height="660" width="1142" />
			<br/>
		</div>
		<div style="text-align: left;">
			<span style="font-weight: bold;">
				根据词法作用域的规则，内部函数getName和setName总是可以访问他们外部函数foo中的变量。
			</span>
			所以当innerBar对象返回给全局变量bar时，虽然foo函数已经执行结束，但是getName和seName函数依然可以使用foo函数中的变量myName和test1。所以当foo函数执行完后，调用栈的状态如下所示：
		</div>
		<div style="text-align: center;">
			<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/ee7c1ca481875ad4bdeb4383bd1f883f.png"
			height="607" width="1142" />
			<br/>
		</div>
		<div>
			<b>
				在javascript中根据词法作用域的规则，内部函数总是可以访问其外部函数声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是foo，那么这些变量的集合就称为foo函数的闭包
			</b>
		</div>
		<ul>
			<li>
				<div>
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						那这些闭包是如何使用的呢？当执行到 bar.setName 方法中的myName = "极客邦"这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo
						函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量，你可以参考下面的调用栈状态图：
					</span>
				</div>
			</li>
		</ul>
		<div style="text-align: center; ">
			<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
				<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/50e4ba60fc7e420e83b35b95e379b246.png"
				height="845" width="1142" />
			</span>
			<br/>
		</div>
		<ol start="9">
			<li>
				<div>
					<b>
						闭包是如何回收的：
					</b>
				</div>
			</li>
		</ol>
		<ul>
			<li>
				<div>
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。
					</span>
				</div>
			</li>
			<li>
				<div>
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么
						JavaScript 引擎的垃圾回收器就会回收这块内存。
					</span>
				</div>
			</li>
			<li>
				<div>
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						所以在使用闭包的时候，你要尽量注意一个原则：
						<b>
							如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。
						</b>
					</span>
				</div>
			</li>
		</ul>
		<div>
			<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
				<b>
					<br/>
				</b>
			</span>
		</div>
		<ol start="10">
			<li>
				<div>
					<font color="#333333" face="PingFang SC">
						<span style="caret-color: rgb(51, 51, 51); font-size: 16px;">
							<b>
								JavaScript中的this是什么？
							</b>
						</span>
					</font>
				</div>
			</li>
		</ol>
		<div style="text-align: center; ">
			<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
				<b>
					<img src="js%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.resources/b398610fd8060b381d33afc9b86f988d.png"
					height="615" width="1142" />
				</b>
			</span>
			<br/>
		</div>
		<div style="text-align: left;">
			<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
				如上图所示，this是和执行上下文绑定的，也就是说每个执行上下文都有一个this
			</span>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						var myObj = {
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						  name : "极客时间",
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						  showThis: function(){
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						    console.log(this)
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						  }
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						}
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						myObj.showThis()
					</span>
				</div>
			</li>
		</ul>
		<div style="text-align: left;">
			<font color="#333333" face="PingFang SC">
				<span style="caret-color: rgb(51, 51, 51); font-size: 16px;">
					结论：
				</span>
			</font>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					<font color="#333333" face="PingFang SC">
						<span style="caret-color: rgb(51, 51, 51); font-size: 16px;">
							 
						</span>
					</font>
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						<b>
							使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
						</b>
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<b>
						<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
							在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。
						</span>
					</b>
				</div>
			</li>
		</ul>
		<div style="text-align: left;">
			<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
				<b>
					<br/>
				</b>
			</span>
		</div>
		<div style="text-align: left;">
			<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
				<b>
					<br/>
				</b>
			</span>
		</div>
		<ol start="11">
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						this 的设计缺陷以及应对方案
					</span>
				</div>
			</li>
		</ol>
		<div style="text-align: left;">
			<b style="color: unset; font-family: unset;">
				<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; orphans: 2; widows: 2;">
					    1.嵌套函数中的 this 不会从外层函数中继承
				</span>
			</b>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					var myObj = {
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					  name : "极客时间",
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					  showThis: function(){
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    console.log(this)
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    function bar(){console.log(this)}
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					    bar()
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					  }
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					}
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					myObj.showThis()
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						发现函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。
					</span>
				</div>
			</li>
		</ul>
		<div style="text-align: left;">
			<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
				可以通过一个小技巧来解决这个问题，比如在 showThis 函数中声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self，代码如下所示：
			</span>
			<br/>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						var myObj = {
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						  name : "极客时间",
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						  showThis: function(){
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						    console.log(this)
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						    var self = this
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						    function bar(){
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						      self.name = "极客邦"
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						    }
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						    bar()
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						  }
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						}
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
						myObj.showThis()
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						<b>
							其实，这个方法的的本质是把 this 体系转换为了作用域的体系。也可以使用es6中的箭头函数解决这个问题
						</b>
					</span>
				</div>
			</li>
		</ul>
		<div style="text-align: left;">
			<font color="#333333" face="PingFang SC">
				<span style="caret-color: rgb(51, 51, 51); font-size: 16px;">
					<b>
						备注： 
					</b>
				</span>
			</font>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。要解决这个问题，你可以有两种思路：
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为
						<b>
							箭头函数没有自己的执行上下文
						</b>
						，所以它会继承调用函数中的 this。
					</span>
				</div>
			</li>
		</ul>
		<div style="text-align: left;">
			<b>
				<span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;;">
					  2.
				</span>
				<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
					普通函数中的 this 默认指向全局对象 window
				</span>
			</b>
		</div>
		<ul>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						在默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。
					</span>
				</div>
			</li>
			<li>
				<div style="text-align: left;">
					<span style="color: rgb(51, 51, 51); font-family: &quot;PingFang SC&quot;, &quot;Lantinghei SC&quot;, &quot;Microsoft Yahei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft Sans Serif&quot;, &quot;WenQuanYi Micro Hei&quot;, Helvetica, sans-serif; font-size: 16px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
						这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了
					</span>
				</div>
			</li>
		</ul>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
		<div>
			<br/>
		</div>
	</body>

</html>