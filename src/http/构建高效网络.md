### Tcp的队头阻塞  

TCP最初是为了单连接而设计的. 从一端到另一端的数据会被拆分为一个个按照顺序排列的数据包, 这些数据包通过网络传输到了接收端, 接收端再按照顺序将这些数据包组合成原始数据, 这样就完成了数据传输.  
如果在数据传输的过程中, 有一个数据因为网络故障或者其他原因而丢包了, 那么整个TCP的连接就会处于暂停状态, 需要等待丢失的数据包被重新传输过来.  
我们把**在TCP传输过程中, 由于单个数据包的丢失而造成的阻塞称为TCP上的队头阻塞.**  

### 队头阻塞时如何影响HTTP/2的传输呢?
HTTP/2中, 多个请求是跑在一个TCP管道中的, 如果其中任意一路数据流出现了丢包的情况, 那么就会阻塞该TCP连接中的所有请求. 这不同于HTTP/1.1, 使用HTTP/1.1时, 浏览器为每个域名开启了6个TCP连接, 如果其中1个TCP连接发生了队头阻塞, 那么其他的5个连接依然可以继续传输数据.  
所以随着丢包率的增加, HTTP/2的传输效率也会越来越差.  

### HTTP/3 QUIC协议
1. 实现了类似TCP的流量控制、传输可靠性的功能. 虽然UDP不提供可靠性的传输、但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输. 它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性.  
2. 集成了TLS加密功能. 目前QUIC使用的是TLS1.3, 相较于早期版本TLS1.3有更多的优点, 其中最重要的一点是减少了握手所花费的RTT个数.  
3. 实现了HTTP/2中的多路复用功能. QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流. 实现了数据流的单独传输, 就解决了TCP中的队头阻塞的问题.  
4. 实现了快速握手功能. 由于QUIC是基于UDP的, 所以QUIC可以实现使用0-RTT或者1-RTT来建立连接, 这意味着QUIC可以用最快的速度来发送和接受数据, 这样可以大大提升首次打开页面的速度.  

### HTTP3的挑战  
1. 服务器和浏览器端都没有对HTTP/3提供比较完整的支持. CHrome虽然在数年前就开始支持Google版本的QUIC, 但是这个版本的QUIC和官方的QUIC存在着非常大的差异.  
2. 部署HTTP/3也存在着非常大的问题. 因为系统内核对UDP的优化远远没有达到TCP的优化程度, 这也是阻碍QUIC的一个重要原因.  
3. 中间设备僵化的问题. 这些设备对UDP的优化程度远远低于TCP, 据统计使用QUIC协议时, 大约有3%-7%的丢包率.  


### 网络延迟(RTT)  
我们把从浏览器发送一个数据包到服务器, 再从服务器返回数据包到浏览器的整个往返时间称为RTT. RTT是反映网路性能的一个重要指标.  


