### HTTP/0.9
主要用于学术交流, 需求很简单——用来在网络之间传递HTML超文本内容, 所以被称为**超文本传输协议**.  
它的实现也很简单, 采用了基于请求响应的模式, 从客户端发出请求, 服务器返回数据.  
三个特点: 
1. 只有一个请求行, 并没有请求头和请求体, 因为只需要一个请求行就可以完整表达客户端的需求了.  
2. 服务器没有返回头信息, 这是因为服务器并不需要告诉客户端太多信息, 只需要返回数据就可以了.  
3. 返回的文件内容是以ASCII字符流来传输的, 因为都是HTML格式的文件, 所以使用ASCII字节码来传输是最合适的.  

### HTTP/1.0
支持多种类型的文件下载是HTTP/1.0的一个核心诉求
HTTP/1.0引入了请求头和响应头, 它们都是以Key-value形式保存的, 在HTTP发送请求时, 会带上请求头信息, 服务器返回数据时, 会先返回响应头信息.  

支持多种类型的文件, 需要解决以下几个问题:  
- 浏览器需要知道服务器返回的数据类型是什么, 然后浏览器才能根据不同的数据类型做针对性的处理
- 为了减轻传输性能, 服务器会对数据进行压缩后再传输, 所以浏览器需要知道服务器压缩的方法.  
- 服务器需要对不同地区提供不同的语言版本, 这就需要浏览器告诉服务器它想要什么语言版本的页面.  
- 浏览器需要知道文件的编码类型.  

```
accept: text/html
accept-encoding: gaip, deflate, br
accept-Charset: ISO-8859-1, utf-8
accept-language: zh-CN, zh
```
如果浏览器不支持gzip, 只支持br压缩, 那么它会通过响应头中的content-encoding字段告诉浏览器最终的压缩类型, 也就是说最终浏览器需要根据响应头的信息来处理数据.  
```
content-encoding: br
content-type: text/html/; charset=UTF-8
```

HTTP/1.0除了对多文件提供支持外的其他特性: 
1. 状态码: 有的请求服务器可能无法处理, 或者处理出错, 这时候就需要告诉浏览器最终处理该请求的情况; 状态码是通过响应行的方式来通知浏览器的.  
2. Cache机制: 为了减轻服务器压力, 用来缓存已经下载过的数据.  
3. 用户代理的字段: 服务器需要统计客户端的基础信息, 比如windows和macOS的用户数量分别是多少.  

### HTTP/1.1  

1. 改进持久连接  
HTTP/1.0每进行一次HTTP通信, 都需要经历建立TCP连接、传输HTTP数据和断开TCP连接三个阶段;  
HTTP/1.1中增加了持久连接的方法, 它的特点是在一个TCP连接上可以传输多个HTTP请求, 只要浏览器或者服务器没有明确断开链接, 那么该TCP连接会一直保持.  
持续连接在HTTP/1.1中是默认开启的, 如果不想要采用持久连接, 可以在HTTP请求头中加上Connection: close.  
目前浏览器中对于同一个域名, 默认允许同时建立6个TCP持久连接.  


2. 不成熟的HTTP管线化  
持续连接虽然能减少TCP的建立和断开次数, 但是它需要等待前面的请求返回之后, 才能进行下一次请求. 如果TCP通道中的某个请求因为某些原因没有及时返回, 那么就会阻塞后面的所有请求, 这就是著名的**队头阻塞**问题.  
HTTP/1.1中试图通过管线化的技术来解决队头阻塞的问题. HTTP/1.1中的管线化是指将多个HTTP请求整批提交给服务器的技术, 虽然可以整批发送请求, 不过服务器依然需要根据请求顺序来回复浏览器的请求.  

3. 提供虚拟主机的支持  
在HTTP/1.0中, 每个域名绑定了一个IP地址, 因此一个服务器只能支持一个域名. 但是随着虚拟主机技术的发展, 需要实现在一台物理主机上绑定多个虚拟主机, 每个虚拟主机都有自己的单独的域名, 这些单独的域名都公用同一个IP地址.  
因此, HTTP/1.1的请求头中增加了Host字段, 用来表示当前的域名地址, 这样服务器就可以根据不同的host值做不同的处理.  

4. 对动态生成的内容提供了完美支持   
在HTTP/1.0中需要在响应头中设置完整的数据大小, 如Content-Length: 901, 这样浏览器就可以根据设置的数据大小来接受数据. 不过随着服务器端的技术发展, 很多页面的内容都是动态生成的, 因此在数据传输之前并不知道最终的数据大小, 这就导致了浏览器不知道何时会接收完所有的文件数据.  

HTTP/1.1通过引入Chunk transfer机制来解决这个问题, 服务器会将数据分割成若干个任意大小的数据块, 每个数据块发送时会附上上个数据块的长度, 最后使用一个零长度的块作为发送数据完成的标志. 这样就提供了对动态内容的支持.  

5. 客户端Cookie、安全机制  
