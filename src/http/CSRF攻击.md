### 什么是CSRF攻击  
CSRF(Cross-site request forgery), 又称为“跨站请求伪造”, 是指黑客引诱用户打开黑客的网站, 在黑客的网站中, 利用用户的登录状态发起的跨站请求.   
简单来讲, CSRF攻击就是黑客利用了用户的登陆状态, 并通过第三方的站点来做一些坏事.  
实施CSRF攻击的方式
1. 自动发起get请求;  
2. 自动发起post请求;  
3. 引诱用户点击链接;  

**和XSS不同的是, CSRF攻击不需要将恶意代码注入用户的页面, 仅仅是利用服务器的漏洞和用户的登录状态来实施攻击.**  

### 如何防止CSRF攻击**

CSRF攻击的三个必要条件: 
- 目标站点有CSRF漏洞;  
- 用户要登录过目标站点, 并且在浏览器上保持有该站点的登录状态;  
- 需要用户打开一个第三方站点, 可以是黑客的站点, 也可以是一些论坛;  

1. 充分利用好Cookie的SameSite属性
Cookie是浏览器和服务器之间维护登陆状态的一个关键数据. 通常XSRF攻击都是从第三方站点发起的, 要防止CSRF攻击, 我们最好能实现从第三方站点发送请求时禁止Cookie的发送, 因此在浏览器通过不同来源发送HTTP请求时, 有如下如区别:  
- 如果是从第三方站点发起请求, 那么需要禁止浏览器发送某些关键Cookie数据到服务器;  
- 如果是同一个站点发起的请求, 需要保证cookie数据正常发送.  

在HTTP响应头中, 通过set-cookie字段设置Cookie时, 可以带上SameSite选项, 如下:  
```

set-cookie: 1P_JAR=2019-10-20-06; expires=Tue, 19-Nov-2019 06:36:21 GMT; path=/; domain=.google.com; SameSite=none
```
**SameSite选项通常有strict、Lax、和None三个值:**  
- strrict最为严格. 如果SameSite的值是Strict, 那么浏览器会完全禁止第三方Cookie.  
- Lax相对宽松一点. 在跨站点的情况下, 从第三方站点的链接打开和从第三方站点提交GEt方式的表单这两种方式都会携带Cookie. 但如果在第三方站点中使用Post方法, 或者通过img、iframe等标签加载的URL, 这些场景都不会携带Cookie.  
- 如果使用None的话, 在任何场景下都会发送Cookie数据.  

2. 在服务端验证请求的来源站点  
Referer是HTTP请求头中的一个字段, 记录了该HTTP请求的来源地址.  
在一些重要场合, 比如通过XMLHttpRequest、Fetch发起跨站请求或者通过Post方法发送请求时, 都会带上Origin属性. origin属性只包含了域名信息, 并没有包含具体的URL路径, 这是Origin和Referer的一个主要区别. 
Origin的值之所以不包含详细路径信息, 是有些站点因为安全考虑, 不想把源站点的详细路径暴露给服务器.  
因此, 服务器的策略是优先判断Origin, 如果请求头中没有包含Origin属性, 再根据实际情况判断是否使用Referer值.  

3. CSRF Token
- 第一步, 在浏览器向服务器发送请求时, 服务器生成一个CSRF Token. CSRF Token其实就是服务器生成的字符串, 然后将该字符串植入到返回的页面中.  
- 第二部, 在浏览器端如果要发起转账的请求, 那么需要带上页面中的CSRF Token, 然后服务器会验证该Token是否合法. 如果是从第三方站点发出的请求, 那么将无法获取到CSRF Token的值, 所以即使发出了请求, 服务器也会因为CSRF Token不正确而拒绝请求.  
