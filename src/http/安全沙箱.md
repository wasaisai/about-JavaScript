从稳定性视角来看, 单进程架构的浏览器是不稳定的.  
- XSS攻击只是将恶意的js脚本注入到页面中, 虽然能窃取一些Cookie相关的数据, 但是XSS无法对操作系统进行攻击.  
- 而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的, 可以读取和修改浏览器进程内部的任意内容, 还可以穿透浏览器, 在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容.  

### 安全视角下的多进程架构  
浏览器被划分为浏览器内核和渲染内核两个核心模块, 其中浏览器内核是由网络进程、浏览器主进程和GPU进程组成的, 渲染内核就是渲染进程.  
所有的网络资源都是通过浏览器内核来下载的, 下载后的资源会通过IPC将其提交给渲染进程(浏览器内核和渲染进程之间都是通过IPC来通信的). 然后渲染进程会对这些资源进行解析、绘制等操作, 最终生成一副图片. 但是渲染进程并不负责将图片显示到界面上, 而是将最终生成的图片提交给浏览器内核模块, 由浏览器内核模块负责显示这张图片.  

### 安全沙箱  
由于渲染进程需要执行DOM解析、CSS解析、网络图片解码等操作, 如果渲染进程中存在系统级别的漏洞, 那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限, 进而又获取操作系统的控制权限, 这对于用户来说是非常危险的.  

如果下载了一个恶意程序, 但是没有执行它, 那么恶意程序是不会生效的.  
我们需要在渲染进程和操作系统之间建一道墙, 即便渲染进程由于存在漏洞被黑客攻击, 但由于这道墙, 黑客就获取不到渲染进程之外的任何操作权限.  
**将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱**

浏览器中的安全沙箱是利用操作系统提供的安全技术, 让渲染进程在执行过程中无法访问或者修改操作系统中的数据, 在渲染进程需要访问系统资源的时候, 需要通过浏览器内核来实现, 然后将访问结果通过IPC转发給渲染进程.  

安全沙箱的最小保护单位是进程.  


### 安全沙箱如何影响各个模块功能  
1. 持久存储  
由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统, 但是在渲染进程内部有访问Cookie的需求、有上传文件的需求, 为了解决这些文件的访问需求, 所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现, 然后通过IPC将操作结果转发給渲染进程.  
- 存储Cookie数据的读写. 通常浏览器内核会维护一个存放所有Cookie的Cookie数据库, 然后当渲染进程通过js来读取cookie时, 渲染进程会通过IPC将读取Cookie的信息发送給浏览器内核, 浏览器内核读取Cookie之后再将内容返回给渲染进程.  
- 一些缓存文件的读写也是由浏览器内核实现的, 比如网络文件缓存的读取.  

2. 网络访问  
有了安全沙箱的保护, 在渲染进程内部不能直接访问网络, 如果要访问网络, 则需要通过浏览器内核. 不过浏览器内核在处理URL请求之前, 会检查渲染进程是否有权限请求该URL, 比如检查XMLHttpRequest或者Fetch是否是跨站点请求, 或者检测HTTPS的站点中是否包含了HTTP的请求.  

3. 用户交互  
通常情况下, 如果你要实现一个UI程序, 操作系统会提供一个届面给你, 该界面允许应用程序与用户交互, 允许应用程序在该界面上进行绘制, 比如windows提供的是HWND, Linux提供的X Window, 我们就把HWND和X Window统称为窗口句柄. 应用程序可以在窗口句柄上进行绘制和接受键盘鼠标消息.  

不过现代浏览器中, 由于每个渲染进程都有安全沙箱的保护, 所以在渲染进程内部是无法直接操作窗口句柄的, 这也是为了限制渲染进程监控到用户的输入事件.    

由于渲染进程不能直接访问**窗口句柄**, 所以渲染进程需要完成以下两点大的改变.  
- 第一点, 渲染进程需要渲染出位图. 为了向用户显示渲染进程渲染出来的位图, 渲染进程需要将生成好的位图发送到浏览器内核, 然后浏览器内核将位图复制到屏幕上.  
- 第二点, 操作系统没有将用户输入事件直接传递給渲染进程, 而是将这些事件传递给浏览器内核. 然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件, 如果当前焦点位于浏览器地址中, 则输入事件会在浏览器内核内部处理; 如果当前焦点在页面的区域内, 则浏览器内核会将输入事件转发给渲染进程.  

之所以这样设计, 就是为了限制渲染进程有监控到用户输入事件的能力, 所以所有的键盘鼠标事件都是由浏览器内核来接收的, 然后浏览器内核再通过IPC将这些事件发送给渲染进程.  

### 站点隔离(Site isolation)  
所谓站点隔离是指Chrome将同一站点(包含了相同根域名和相同协议的地址)中相互关联的页面放到同一个渲染进程中执行.  

最开始Chrome划分渲染进程是以标签页为单位, 也就是说整个标签页会被划分給某个渲染进程. 但是, 按照标签页划分渲染进程存在一些问题, 原因就是一个标签页中可能包含了多个iframe, 而这些iframe又有可能来自于不同的站点, 这就导致了多个不同站点中的内容通过iframe同时运行在同一个渲染进程中.  

目前所有的操作系统都面临两个A级漏洞——幽灵(Spectre) 和熔毁(Meltdown), 这两个漏洞是由处理器架构导致的, 很难修补, 黑客通过这两个漏洞可以直接入侵到进程的内部, 如果入侵的进程没有安全沙箱的保护, 那么黑客可以发起多操作系统的攻击.  
因此, chrome将标签级的渲染进程重构为iframe级的渲染进程, 然后严格按照同一站点的策略来分配渲染进程, 这就是chrome中的站点隔离.  


