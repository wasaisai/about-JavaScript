### 垃圾回收算法
1. 通过GC Root标记空间中活动对象和非活动对象.   
目前V8采用的**可访问性(reachability)算法**来判断堆中的对象是否是活动对象.具体地将, 这个算法是将一些GC Root作为初始存活的对象的集合, 从CG Roots对象出发, 遍历GC Root中的所有对象:  
- 通过 GC Root遍历到的对象, 我们就认为该对象是可访问的, 那么必须保证这些对象应该在内存中保留, 我们也称可访问的对象为活动对象.  
- 通过GC Roots没有遍历到的对象, 则是**不可访问(unreachable)**, 那么这些不可访问的对象就可能被回收, 我们称不可访问的对象为非活动对象.  

在浏览器中, GC Root有很多, 通常包括了以下几种(但是不止于这几种):  
- 全局window对象(位于每个ifarme中);  
- 文档DOM树, 由可以通过遍历文档到达的所有原生DOM节点组成;  
- 存放在栈上的变量;  
<br>

2. 回收非活动对象所占据的内存. 其实就是在所有的标记完成之后, 统一清理内存中所有被标记为可回收的对象.  
3. 做内存整理. 一般来说, 频繁回收对象后, 内存中就会存在大量不连续空间, 我们把这些不连续的内存空间称为**内存碎片**. 当内存中出现大量的内存碎片后, 如果需要分配比较大的连续内存时, 就有可能出现内存不足的情况, 所以最后一步需要整理这些内存碎片. 但这步其实是可选的, 因为有的垃圾回收器不会产生内存碎片, 比如副垃圾回收器.  

<br>  

目前V8采用了两个垃圾回收器, **主垃圾回收器 -Major GC和副垃圾回收器 -Minor GC(Scavenger)** . V8之所以使用了两个垃圾回收器, 主要是受到了**代际假说(The Generational Hypothesis)**的影响.  

**代际假说的两个特点**:  
- 大部分对象都是“朝生夕死”的, 也就是说大部分对象在内存中存活的时间很短, 比如函数内部声明的变量, 或者块级作用域的变量, 当函数或者代码块执行结束时, 作用域中定义的变量就会被销毁. 因此这一类对象一经分配内存, 很快就变得不可访问;  
- 不死的对象, 会活的更久, 比如全局的window、DOM、Web API等对象.  

<br>

在V8中, 会把堆分为新生代和老生代两个区域, **新生代中存放的是生存时间短的对象, 老生代中存放生存时间久的对象**.  
新生代通常只支持1~8M的容量, 而老生代支持的容量就大很多了. 对于这两块的区域, V8分别使用两个不同的垃圾回收器, 以便更高效地实施垃圾回收.  
- **副垃圾回收器 -Minor GC(Scavenger), 主要负责新生代的垃圾回收**. 
- **主垃圾回收 -Major GC, 主要负责老生代的垃圾回收**. 

<br>  

### 副垃圾回收器  
新生代中的垃圾数据用**Scavenge算法**来处理. 所谓Scavenge算法, 是把新生代空间对半划分为两个区域, 一半是**对象区域(from-space)**, 一般是空闲区域(to-space)**;  


新加入的对象都会被存放到对象区域, 当对象区域快被写满时, 就需要执行一次垃圾清理操作.  


在垃圾回收过程中, 首先要对对象区域中的垃圾做标记; 标记完成之后, 就进入垃圾清理阶段. 副垃圾回收器会把这些存活的对象复制到空闲区域中, 同时它还会把这些对象有序地排列起来, 所以这个复制过程, 也就相当于完成了内存整理操作, 复制后空闲区域就没有内存碎片了.  


完成复制后, 对象区域与空闲区域进行角色翻转, 也就是原来的对象区域变成空闲区域, 原来的空闲区域变成了对象区域. 这样就完成了垃圾对象的回收操作, 同时, **这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去**.  


副垃圾回收器每次执行清理操作时, 都需要将存活的对象从对象区域复制到空闲区域, 复制操作需要时间成本, 如果新生区空间设置的太大, 那么每次清理的时间就会过久, 所以**为了执行效率, 一般新生区的空间会被设置的比较小**.  

也正是因为新生区的空间不大, 所以很容易被存活的对象装满整个区域, 副垃圾回收器一旦监控对象装满了, 便执行垃圾回收. 同时, 副垃圾回收器还会采用**对象晋升策略**, 也就是移动那些经过两次垃圾回收依然存活的对象到老生代中.  

### 主垃圾回收器  
主垃圾回收器主要负责老生代中的垃圾回收. 除了新生代中晋升的对象, 一些大的对象会直接被分配到老生代里, 因此, 老生代的对象有两个特点:  
- 对象占用空间大;  
- 对象存活时间长;  

<br>  

由于老生代对象比较大, 若采用Scavenge算法进行垃圾回收, 复制这些大的对象将会花费比较多的时间, 从而导致回收执行效率不高, 同时还会浪费一半的空间. 所以, 主垃圾回收器采用**标记 - 清除(Mark-Sweep)**的算法进行垃圾回收.  
1. **首先是标记过程阶段**. 标记阶段就是从一组根元素开始, 递归遍历这组根元素, 在这个遍历过程中, 能达到的元素称为活动对象, 没有到达的元素就可以判断为垃圾数据.  
2. **接下来就是垃圾清除过程**. 它和副垃圾回收器的垃圾清除过程完全不同, 主垃圾回收器会直接将标记为垃圾的数据清理掉.  


对垃圾数据进行标记, 然后清除, 这就是**标记-清楚算法**, 不过对一块内存多次执行标记-清除算法后, 会产生大量不连续的内存碎片. 而碎片过多会导致大对象无法分配到足够的连续内存, 于是又引入了另外一种算法——**标记 - 整理(Mark-Compact)**.  


这个算法的标记过程任然与标记-清除算法里的是一样的, 先标记可回收对象, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉这一端之外的内存.  

