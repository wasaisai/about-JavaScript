由于js是运行在主线程之上的, 因此, 一旦执行垃圾回收算法,没都需要将正在执行的js脚本暂停下来, 待垃圾回收完毕后再恢复脚本执行. 我们把这种行为叫做**全停顿(Stop-The-World)**.  

为了解决全停顿而造成的用户体验问题, V8团队经过了很多年的努力, 向现有的垃圾回收器添加并行、并发和增量等垃圾回收技术, 并且也已经取得了一些成效. 这些技术主要是从两方面来解决垃圾回收效率问题的:  
1. **将一个完整的垃圾回收的任务拆分成多个小任务**, 这样就消灭了单个长的垃圾回收任务.  
2. 将**标记对象、移动对象等任务转移到后台线程进行**,  这会大大减少主线程暂停的时间, 改善页面卡顿的问题, 让动画、滚动和用户交互更加流畅.  

### 并行回收  
执行一次完整的垃圾回收过程比较耗时, 那么解决效率问题, 第一个思路是主线程在执行垃圾回收的任务时, 引入多个辅助线程来并行处理, 这样就会加速垃圾回收的执行速度, 因此V8团队引入了并行回收机制.  

所谓并行回收, 是指垃圾回收器在主线程上执行的过程中, 还会开启多个协助线程, 同时执行同样的回收工作.  

V8的副垃圾回收器所采用的就是并行策略, 它在执行垃圾回收的过程中, 启动了多个线程来负责新生代中的垃圾清理操作, 这些线程同时将对象空间中的数据移动到空闲区域. 由于数据的地址发生了变化, 所以还需要同步更新引用这些对象的指针.  

<br>  

### 增量回收  
虽然并行策略能增加垃圾回收的效率, 能够很好地优化副垃圾回收器, 但是这**任然是一种全停顿**的垃圾回收方式, 在主线程执行回收工作的时候才会开启辅助线程, 这依然还会存在效率问题. 比如老生代存放的都是一些大的对象, 如window、DOM这种, 完整执行老生代的垃圾回收, 时间依然会很久. 这些大的对象都是主垃圾回收器的, 所以在2011年, V8又引入了增量标记的方式, 我们把这种垃圾回收的方式称之为**增量式垃圾回收**.  

所谓增量式垃圾回收, 是指垃圾收集器将标记工作分解为更小的块, 并且穿插在主线程不同的任务之间执行. 采用增量垃圾回收时, 垃圾回收没有必要一次执行完整的垃圾回收过程, 每次执行的只是整个垃圾回收过程中的一小部分工作.  

增量标记的算法, 比全停顿的算法要稍微复杂, 这主要是因为**增量回收是并发的(concurrent)**, 要实现增量执行, 需要满足两点要求:  
1. 垃圾回收可以被随时暂停和重启, 暂停时需要保存当时的扫描结果, 等下一波垃圾回收来了之后, 才能继续启动.  
2. 在暂停期间, 被标记好的垃圾数据如果被js代码修改了, 那么垃圾回收器需要能够正确处理.   

