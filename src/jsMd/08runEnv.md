### 运行时环境
在执行js代码之前, v8就已经准备好了代码的运行时环境, 这个环境包括了堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象, 还有消息循环系统.  
<br>
### 宿主环境  
浏览器为V8提供基础的消息循环系统、全局变量、WebAPI、而V8的核心是实现了ECMAScript标准.  
除了浏览器, Node.js也是V8的另外一种宿主环境, 它提供了不同的宿主对象和宿主API, 但整个流程依然是相同的, 比如Node.js也会提供一套消息循环系统, 也会提供一个运行时的住线程.  
<br>
### 构造数据的存储空间: 堆空间和栈空间  
由于V8时寄生在浏览器或者nodejs这些宿主中的, 因此, V8也是被这些宿主启动的. 比如在chrome中, 只要打开一个渲染进程, 渲染进程便会初始化V8, 同时初始化堆空间和栈空间.  

栈空间主要是用来管理JavaScript函数调用的, 栈是内存中连续的一块空间, 同时栈结构是“先进后出”的策略. 在函数调用的过程中, 涉及到上下文相关的内容都会存放在栈上, 比如原生类型、引用到的对象的地址、函数的执行状态、this值等都会存在栈上.  当一个函数执行结束, 那么该函数的执行上下文便会被销毁掉.  

**栈空间**的最大特点是空间连续, 所以在栈中每个元素的地址都是固定的, 因此栈空间的查找效率非常高, 但是通常在内存中, 很难分配到一块很大的连续空间, 因此, V8对栈空间大小做了限制, 如果函数调用层过深, 那么V8就有可能抛出栈溢出的错误.  

**堆空间**是一种树形的存储结构, 用来存储对象类型的离散的数据; 如果一些占用内存比较大的数据, 或者不需要存储在连续空间中的数据, 使用栈空间就显得不太合适了, 所以V8使用了堆空间;  诸如函数、数组、在浏览器中还有window对象、document对象等,这些都是存在堆空间.  
<br>  
### 全局执行上下文和全局作用域  
V8开始执行一段可执行代码时, 会生成一个执行上下文.V8用执行上下文来维护执行当前代码所需要的变量声明、this指向等. 

执行上下文中主要包含三部分, 变量环境、词法环境和this关键字. 比如在浏览器环境中, 全局执行上下文中就包括了window对象, 还有默认指向window的this关键字, 另外还有一些web API函数, 诸如setTimeout、XMLHttoRequest等内容.  

而词法环境中, 则包含了使用let、const等变量的内容.  

全局执行上下文在V8的生存周期内是不会被销毁的, 它会一直保存在堆中, 这样当下次在需要使用函数或者全局变量时, 就不需要重新创建了.  
另外, 当你执行了一段全局代码时, 如果全局代码中有声明的函数或者定义的变量, 那么函数对象和声明的变量都会被添加到全局上下文中.  

全局作用域和全局执行上下文的关系, 其实可以把作用域看成是一个抽象的概念, 比如在ES6中, 同一个全局执行上下文中, 都能存在多个作用域.  
<br>  
### 构造事件循环系统  
有了堆空间和栈空间, 生成了全局执行上下文和全局作用域, 接下来就可以执行js代码了吗?  
答案是不行, 因为V8还需要有一个主线程, 用来执行js和执行垃圾回收等工作. V8是寄生在宿主环境中的, 它并没有自己的主线程, 而是使用宿主提供的主线程, V8所执行的代码都是在宿主的主线程上执行的.  

只有一个主线程依然不行, 因为如果开启一个线程,在该线程执行一段代码, 那么当该线程执行完这段代码之后, 就会自动退出了, 执行过程中的一些栈上的数据也随之被销毁, 下次再执行另外一段代码时, 需要重新启动一个线程, 重新初始化栈数据, 这会严重影响到程序执行是的性能.  

为了在执行完代码后, 让线程继续运行, 通常的做法是在代码中添加一个循环语句, 在循环语句中监听下个事件, 比如执行另外一个语句, 那么激活该循环就可以执行了.  

如果主线程正在执行一个任务, 这时候又来了一个新任务, 比如V8正在操作DOM, 这是浏览器的网络线程完成了一个页面下载的任务, 而且V8监听下载完成的事件, 那么这种情况下就需要引入一个消息队列, 让下载完成的事件暂存到消息队列中, 等当前的任务执行结束之后, 再从消息队列中取出正在排队的任务. 当执行完一个任务后, 事件循环系统会重复这个过程, 继续从消息队列中取出并执行下个任务.  

因为所有任务都是运行在主线程的, 在浏览器的页面中, V8会和页面共用主线程, 共用消息队列, 所以如果V8执行一个函数过久, 会影响到浏览器页面的交互性能.  





